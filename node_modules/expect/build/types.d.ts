/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
import type { Config } from '@jest/types';
import type * as jestMatcherUtils from 'jest-matcher-utils';
import { INTERNAL_MATCHER_FLAG } from './jestMatchersObject';
export declare type SyncExpectationResult = {
    pass: boolean;
    message: () => string;
};
export declare type AsyncExpectationResult = Promise<SyncExpectationResult>;
export declare type ExpectationResult = SyncExpectationResult | AsyncExpectationResult;
export declare type RawMatcherFn<T extends MatcherState = MatcherState> = {
    (this: T, received: any, expected: any, options?: any): ExpectationResult;
    [INTERNAL_MATCHER_FLAG]?: boolean;
};
export declare type ThrowingMatcherFn = (actual: any) => void;
export declare type PromiseMatcherFn = (actual: any) => Promise<void>;
export declare type Tester = (a: any, b: any) => boolean | undefined;
export declare type MatcherState = {
    assertionCalls: number;
    currentTestName?: string;
    dontThrow?: () => void;
    error?: Error;
    equals: (a: unknown, b: unknown, customTesters?: Array<Tester>, strictCheck?: boolean) => boolean;
    expand?: boolean;
    expectedAssertionsNumber?: number | null;
    expectedAssertionsNumberError?: Error;
    isExpectingAssertions?: boolean;
    isExpectingAssertionsError?: Error;
    isNot: boolean;
    promise: string;
    suppressedErrors: Array<Error>;
    testPath?: Config.Path;
    utils: typeof jestMatcherUtils & {
        iterableEquality: Tester;
        subsetEquality: Tester;
    };
};
export interface AsymmetricMatcher {
    asymmetricMatch(other: unknown): boolean;
    toString(): string;
    getExpectedType?(): string;
    toAsymmetricMatcher?(): string;
}
export declare type MatchersObject<T extends MatcherState = MatcherState> = {
    [id: string]: RawMatcherFn<T>;
};
export declare type ExpectedAssertionsErrors = Array<{
    actual: string | number;
    error: Error;
    expected: string;
}>;
interface AsymmetricMatchers {
    any(sample: unknown): AsymmetricMatcher;
    anything(): AsymmetricMatcher;
    arrayContaining(sample: Array<unknown>): AsymmetricMatcher;
    closeTo(sample: number, precision?: number): AsymmetricMatcher;
    objectContaining(sample: Record<string, unknown>): AsymmetricMatcher;
    stringContaining(sample: string): AsymmetricMatcher;
    stringMatching(sample: string | RegExp): AsymmetricMatcher;
}
export declare type Expect<State extends MatcherState = MatcherState> = {
    <T = unknown>(actual: T): Matchers<void, T>;
    addSnapshotSerializer(serializer: unknown): void;
    assertions(numberOfAssertions: number): void;
    extend<T extends MatcherState = State>(matchers: MatchersObject<T>): void;
    extractExpectedAssertionsErrors: () => ExpectedAssertionsErrors;
    getState(): State;
    hasAssertions(): void;
    setState(state: Partial<State>): void;
} & AsymmetricMatchers & {
    not: Omit<AsymmetricMatchers, 'any' | 'anything'>;
};
export interface Matchers<R, T = unknown> {
    /**
     * Ensures the last call to a mock function was provided specific args.
     */
    lastCalledWith(...expected: [unknown, ...Array<unknown>]): R;
    /**
     * Ensure that the last call to a mock function has returned a specified value.
     */
    lastReturnedWith(expected: unknown): R;
    /**
     * If you know how to test something, `.not` lets you test its opposite.
     */
    not: Matchers<R, T>;
    /**
     * Ensure that a mock function is called with specific arguments on an Nth call.
     */
    nthCalledWith(nth: number, ...expected: [unknown, ...Array<unknown>]): R;
    /**
     * Ensure that the nth call to a mock function has returned a specified value.
     */
    nthReturnedWith(nth: number, expected: unknown): R;
    /**
     * Use resolves to unwrap the value of a fulfilled promise so any other
     * matcher can be chained. If the promise is rejected the assertion fails.
     */
    resolves: Matche